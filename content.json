{"meta":{"title":"天沐凉风","subtitle":"光赐于苦","description":"南昌大学22级计算机科学与技术的一名学生，虽然目前什么也不会，但是我会努力加油的:>","author":"mu1226","url":"http://mu1226.github.io","root":"/"},"pages":[{"title":"","date":"2025-05-14T07:16:55.280Z","updated":"2025-05-14T07:16:55.280Z","comments":true,"path":"404.html","permalink":"http://mu1226.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-05-14T07:16:55.283Z","updated":"2025-05-14T07:16:55.283Z","comments":true,"path":"about/index.html","permalink":"http://mu1226.github.io/about/index.html","excerpt":"","text":"天沐凉风 的食用指南云峦波涛，千里枯路，江山故人我，晚秋行舟 欢迎来到我的博客，如你所见，这里的一切几乎都与 明日方舟 有关。作为一名游玩时长114514小时的牢玩家，方舟的元素已经融入到了我生活的每一个角落，可以说有 天沐凉风 的地方就一定会有 明日方舟 。 到这里就不得不提到，我非常喜欢的方舟角色之一———— 令 ，作为十二岁兽碎片之一，也同样是岁兽家族的 三姐 ，在人间游走多年，看穿这世俗凡尘，练得一身逍遥自在的气质，这何尝不是一种 走遍这天下世间的风 呢？ 关于我对了，忘记做介绍了。 天沐凉风 ，一个非常有时间味道的名字，经过长达六年的沉淀，经过 天末凉风 -&gt; 天未凉风 -&gt; 天沐凉风 的转变，我本人对这个昵称太满意了，感觉这个昵称很有动感，单一个 沐 字，既衬托出 天 的广阔，又隐晦地点出 风 的自由，二者相互点缀，妙哉！ 爱好 数学：具有三年的数学学习经历，两次参加全国大学生数学竞赛（CMC，Chinese Mathematics Competitions） 第十五届全国大学生数学竞赛决赛二等奖 第十六届全国大学生数学竞赛决赛二等奖 游戏：具有多年游玩电子游戏的经历，多次氪金648（已戒），多次参加CMC（Cash money, Caput） 王者荣耀 明日方舟 原神（启动） 荒野大镖客2 星露谷物语 Minecraft 我的背景 专业：计算机科学与技术（卓越工程师计划） 职业：无业游民，目前从事 蹲大学 工作 学校：江西某211 学历：苯科 我的目标与愿景我希望未来可以从事游戏开发相关的工作。在游戏开发的全过程中，除了改BUG，其余时间都是快乐的（废话），我能感受到不同于开发其他项目的感觉。在做游戏的时候，我并不觉得疲倦，反而充满精神，一天干十个小时的开发工作不在话下。诸位，我会朝着我的目标前进的! ———— 天沐凉风 联系我如果你对我的工作感兴趣，或者有任何问题、建议，欢迎随时联系我！我非常乐意听到你的声音。 电子邮件：&#x6d;&#x31;&#51;&#x37;&#x35;&#x35;&#57;&#x39;&#50;&#x38;&#x36;&#48;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109; 感谢你访问我的页面，希望我们能有更多的交流！"},{"title":"archives","date":"2025-05-11T03:42:34.000Z","updated":"2025-05-14T07:16:55.284Z","comments":true,"path":"archives/index.html","permalink":"http://mu1226.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-05-14T07:16:55.284Z","updated":"2025-05-14T07:16:55.284Z","comments":true,"path":"categories/index.html","permalink":"http://mu1226.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-05-14T07:16:55.401Z","updated":"2025-05-14T07:16:55.401Z","comments":true,"path":"tags/index.html","permalink":"http://mu1226.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Web程序设计大作业","slug":"Web程序设计大作业","date":"2025-05-29T02:06:23.000Z","updated":"2025-05-29T02:09:42.462Z","comments":true,"path":"2025/05/29/Web程序设计大作业/","permalink":"http://mu1226.github.io/2025/05/29/Web%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"在线聊天系统项目报告一、需求分析本在线聊天系统旨在为用户提供一个便捷、实时的在线交流平台。系统的主要用户为普通注册用户。 1. 用户需求系统需要满足用户的以下主要需求： 登录与注册： 用户能够通过邮箱进行新用户注册，并设置登录的用户名和密码。 已注册用户可以使用注册时提供的邮箱和密码登录系统。 系统应提供密码找回机制，帮助用户在忘记密码时重设密码。 聊天管理： 私聊功能： 用户可以根据用户名或邮箱等信息搜索其他用户，并发送好友请求。 用户可以与已添加的好友进行一对一的实时文本聊天。 聊天过程中支持发送预设的表情符号，增加聊天的趣味性。 用户可以方便地查看与特定好友的历史聊天记录。 用户应能够选择将与好友的聊天记录下载到本地设备进行保存。 群聊功能： 用户可以创建新的聊天群组，并自动成为该群组的群主，拥有管理权限。 用户可以根据群名称或群号搜索现有的群组，并提交加入申请。 群主可以管理群成员，包括审批新的加群申请（同意或拒绝）。 群组成员可以在群聊界面中进行多人实时文本交流。 群聊中同样支持发送表情符号。 用户可以查看所在群组的历史聊天记录。 用户应能够选择将群组的聊天记录下载到本地设备进行保存。 语音聊天： 在私聊或群聊场景下，用户可以发送语音消息。 好友管理： 用户可以清晰地查看自己的好友列表。 支持对好友进行分组管理，方便用户组织和查找好友。 用户可以从好友列表中删除指定的好友。 对于已发送但对方未处理的好友请求，用户可以重新发送验证信息。 个人信息管理： 用户可以修改自己的个人资料，如头像、昵称、个性签名等。 用户可以修改当前的登录密码，以保障账户安全。 2. 系统功能模块根据上述用户需求分析，本在线聊天系统主要包含以下核心功能模块： 用户认证模块： 功能点：用户注册、用户登录、用户登出、密码找回。 好友管理模块： 功能点：搜索用户、添加好友、删除好友、同意&#x2F;拒绝好友请求、好友列表展示、好友分组管理、移动好友分组、重新发送验证信息。 群组管理模块： 功能点：创建群组、搜索群组、申请加群、审批加群请求、退出群组、解散群组（群主权限）、群成员管理。 消息模块： 功能点：私聊消息发送与接收（文本、表情）、群聊消息发送与接收（文本、表情）、语音通话信令处理、消息实时推送。 聊天记录模块： 功能点：私聊记录查询、群聊记录查询、聊天记录下载。 个人中心模块： 功能点：查看个人信息、修改个人信息（头像、昵称、签名）、修改密码。 3. 系统顶级用例图为了更直观地展示用户与系统主要功能的交互，绘制系统顶级用例图如下： 12345678910111213141516171819202122232425262728293031323334353637left to right directionactor 用户rectangle 在线聊天系统 &#123; usecase &quot;用户注册&quot; as UC1 usecase &quot;用户登录&quot; as UC2 usecase &quot;密码找回&quot; as UC3 usecase &quot;添加好友&quot; as UC4 usecase &quot;好友分组管理&quot; as UC4a usecase &quot;删除好友&quot; as UC4b usecase &quot;私聊&quot; as UC5 usecase &quot;创建群组&quot; as UC6 usecase &quot;加入群组&quot; as UC7 usecase &quot;群聊&quot; as UC8 usecase &quot;查看聊天记录&quot; as UC9 usecase &quot;下载聊天记录&quot; as UC10 usecase &quot;管理好友列表&quot; as UC11 usecase &quot;管理群组信息/成员&quot; as UC12 usecase &quot;修改个人信息&quot; as UC13 usecase &quot;发起/加入语音聊天&quot; as UC14&#125;用户 -- UC1用户 -- UC2用户 -- UC3用户 -- UC4用户 -- UC4a用户 -- UC4b用户 -- UC5用户 -- UC6用户 -- UC7用户 -- UC8用户 -- UC9用户 -- UC10用户 -- UC11用户 -- UC12用户 -- UC13用户 -- UC14 图 1 系统顶级用例图 二、数据库设计本系统选用 MySQL 作为后端数据存储的数据库管理系统。根据系统需求分析阶段确定的功能模块和数据实体，设计了以下主要的数据表结构及其关系。 1. 数据表设计详细的数据表结构如下： **用户信息表 (user_info)**：存储用户的基本注册信息和个人资料。 id (INT, PK, AI): 自增主键，唯一标识每条记录。 user_id (VARCHAR(50), UK, NN): 用户唯一标识符，例如UUID，用于系统内部关联。 name (VARCHAR(100), NN): 用户昵称。 email (VARCHAR(100), UK, NN): 用户注册邮箱，具有唯一性约束，用于登录和密码找回。 password (VARCHAR(255), NN): 用户登录密码，存储时应进行加密处理（例如使用 bcrypt）。 picture (VARCHAR(255)): 用户头像的URL或存储路径。 signature (VARCHAR(255)): 用户个性签名。 **好友关系表 (friends)**：记录用户之间的好友关系。 id (INT, PK, AI): 自增主键。 user_id (VARCHAR(50), NN, FK -&gt; user_info.user_id): 用户自身的ID。 contact_id (VARCHAR(50), NN, FK -&gt; user_info.user_id): 好友的用户ID。 state (TINYINT, NN): 好友关系状态。例如：0 表示待同意，1 表示已同意&#x2F;互为好友。 **群组信息表 (group_info)**：存储聊天群组的基本信息。 id (INT, PK, AI): 自增主键。 group_id (VARCHAR(50), UK, NN): 群组唯一标识符，例如UUID。 group_name (VARCHAR(100), NN): 群组名称。 group_owner (VARCHAR(50), NN, FK -&gt; user_info.user_id): 群组创建者的用户ID。 group_number (VARCHAR(6)): 群号，一个简短易记的群组标识，可选，方便用户搜索。 **群组用户关系表 (group_user)**：记录用户与群组的成员关系。 id (INT, PK, AI): 自增主键。 group_id (VARCHAR(50), NN, FK -&gt; group_info.group_id): 群组的ID。 user_id (VARCHAR(50), NN, FK -&gt; user_info.user_id): 用户的ID。 state (TINYINT, NN, DEFAULT 0): 用户在群组中的状态。例如：0 表示申请加入，1 表示已加入，2 表示已拒绝。 **历史消息表 (history_messages)**：存储用户之间以及群组内的聊天消息。 id (INT, PK, AI): 自增主键。 sender (VARCHAR(50), NN, FK -&gt; user_info.user_id): 消息发送者的用户ID。 receiver (VARCHAR(50), NN): 消息接收者。对于私聊，是对方用户的ID；对于群聊，是群组的ID。 message (TEXT, NN): 消息的具体内容。对于文本消息，是文本字符串；对于语音消息，可以是语音文件的URL或相关元数据。 msg_type (VARCHAR(100), NN): 消息类型。例如：private (私聊), group (群聊)。 group_name (VARCHAR(50)): 如果是群聊消息，记录群组名称，私聊时可为空。 timestamp (TIMESTAMP, NN, DEFAULT CURRENT_TIMESTAMP): 消息发送的服务器时间戳。 content_type (VARCHAR(20)): 消息内容的具体类型，例如 text (文本), voice (语音), image (图片)。 voice_url (VARCHAR(200)): 如果是语音消息，存储语音文件的访问URL。 voice_duration (INT): 如果是语音消息，记录语音的时长（单位：秒）。 **好友分类表 (type_info)**：存储用户自定义的好友分组信息。 id (INT, PK, AI): 自增主键。 type_id (VARCHAR(50), UK, NN): 分类唯一标识符。 type_name (VARCHAR(100), NN): 分类名称 (例如：“家人”、“同事”、“同学”)。 user_id (VARCHAR(50), NN, FK -&gt; user_info.user_id): 该分类所属用户的ID。 **分类与用户关系表 (type_user)**：记录好友具体属于哪个分类。 id (INT, PK, AI): 自增主键。 type_id (VARCHAR(50), NN, FK -&gt; type_info.type_id): 分类的ID。 user_id (VARCHAR(50), NN, FK -&gt; user_info.user_id): 被归类的那个好友的用户ID。 2. E-R 图 (实体关系图)下图展示了本系统主要数据实体及其之间的关系： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071erDiagram USER_INFO &#123; varchar(50) user_id PK &quot;用户ID&quot; varchar(100) name NN &quot;昵称&quot; varchar(100) email UK, NN &quot;邮箱&quot; varchar(255) password NN &quot;密码&quot; varchar(255) picture &quot;头像URL&quot; varchar(255) signature &quot;个性签名&quot; &#125; FRIENDS &#123; int id PK &quot;主键&quot; varchar(50) user_id NN, FK &quot;用户ID&quot; varchar(50) contact_id NN, FK &quot;好友ID&quot; tinyint state NN &quot;好友状态&quot; &#125; GROUP_INFO &#123; int id PK &quot;主键&quot; varchar(50) group_id UK, NN &quot;群组ID&quot; varchar(100) group_name NN &quot;群组名称&quot; varchar(50) group_owner NN, FK &quot;群主ID&quot; varchar(6) group_number &quot;群号&quot; &#125; GROUP_USER &#123; int id PK &quot;主键&quot; varchar(50) group_id NN, FK &quot;群组ID&quot; varchar(50) user_id NN, FK &quot;用户ID&quot; tinyint state NN &quot;用户群内状态&quot; &#125; HISTORY_MESSAGES &#123; int id PK &quot;主键&quot; varchar(50) sender NN, FK &quot;发送者ID&quot; varchar(50) receiver NN &quot;接收者ID/群组ID&quot; text message NN &quot;消息内容&quot; varchar(100) msg_type NN &quot;消息类型&quot; varchar(50) group_name &quot;群组名称&quot; timestamp timestamp NN &quot;发送时间&quot; varchar(20) content_type &quot;内容类型&quot; varchar(200) voice_url &quot;语音URL&quot; int voice_duration &quot;语音时长&quot; &#125; TYPE_INFO &#123; int id PK &quot;主键&quot; varchar(50) type_id UK, NN &quot;分类ID&quot; varchar(100) type_name NN &quot;分类名称&quot; varchar(50) user_id NN, FK &quot;所属用户ID&quot; &#125; TYPE_USER &#123; int id PK &quot;主键&quot; varchar(50) type_id NN, FK &quot;分类ID&quot; varchar(50) user_id NN, FK &quot;好友用户ID&quot; &#125; USER_INFO ||--o&#123; FRIENDS : &quot;发起/接收好友请求&quot; USER_INFO ||--o&#123; GROUP_USER : &quot;加入/被加入群组&quot; USER_INFO ||--o&#123; GROUP_INFO : &quot;创建群组&quot; USER_INFO ||--o&#123; HISTORY_MESSAGES : &quot;发送/接收消息&quot; USER_INFO ||--o&#123; TYPE_INFO : &quot;创建好友分类&quot; FRIENDS &#125;o--|| USER_INFO : &quot;是...的好友&quot; GROUP_INFO ||--o&#123; GROUP_USER : &quot;拥有成员&quot; GROUP_INFO ||--o&#123; HISTORY_MESSAGES : &quot;包含群消息&quot; TYPE_INFO ||--o&#123; TYPE_USER : &quot;包含好友&quot; TYPE_USER &#125;o--|| USER_INFO : &quot;属于分类&quot; 图 2 系统E-R图 三、架构设计本在线聊天系统采用前后端分离的架构模式，后端采用 Java Spring Boot 框架，前端采用 Vue.js 框架。这种架构模式有助于提高开发效率、降低耦合度，并使得前后端可以独立部署和扩展。 1. 后端架构 (Java Spring Boot)后端项目 java-chat-room 主要负责业务逻辑处理、数据持久化、API接口提供以及实时消息通讯。 分包依据及主要类的作用： com.mh.ChatRoomApplication.java: Spring Boot 主启动类，负责应用的初始化和启动。 com.mh.common: 通用组件包。 ChatWebSocketHandler.java: WebSocket 处理器，负责处理客户端的 WebSocket 连接、消息的接收与广播，是实现实时聊天的核心组件。 RabbitMessageListener.java: RabbitMQ 消息监听器，用于异步处理消息，例如消息持久化、离线消息推送等。 UserLoginInterceptor.java: 用户登录拦截器，用于校验用户登录状态，保护需要授权访问的接口。 com.mh.config: 配置类包，存放应用的各种配置信息。 MailConfiguration.java: 邮件服务配置，用于实现注册验证码发送、密码找回等功能。 MyBatisPlusConfig.java: MyBatisPlus 配置，用于简化数据库操作。 RabbitMQConfig.java: RabbitMQ 配置，定义交换机、队列和绑定关系，用于消息队列服务。 RedisConfig.java: Redis 配置，用于缓存常用数据，提高系统性能，例如存储用户在线状态、会话信息等。 SecurityConfig.java: Spring Security 配置，用于密码加密、权限控制等安全相关设置。 SwaggerConfig.java: Swagger API 文档配置，自动生成API文档，方便前后端联调和接口查阅。 WebMvcConfig.java: Web MVC 配置，例如配置拦截器、静态资源处理等。 WebSocketConfig.java: WebSocket 配置，启用 WebSocket 支持并注册 ChatWebSocketHandler。 com.mh.constants: 常量定义包。 CommonStatic.java: 通用静态常量。 MessageType.java: 消息类型常量定义，如私聊、群聊、系统通知等。 com.mh.controller: 控制器层 (Controller)，负责接收前端HTTP请求，调用Service层处理业务逻辑，并返回响应数据。 CommonController.java: 通用功能接口，如文件上传、验证码发送等。 FriendsController.java: 好友管理相关接口。 GroupInfoController.java: 群组信息管理相关接口。 GroupUserController.java: 群组成员管理相关接口。 HistoryMessagesController.java: 聊天记录查询与下载相关接口。 TypeInfoController.java: 好友分组信息管理相关接口。 TypeUserController.java: 好友与分组关系管理相关接口。 UserInfoController.java: 用户信息管理、登录、注册相关接口。 com.mh.dao: 数据访问对象层 (DAO&#x2F;Mapper)，负责与数据库进行交互，执行SQL语句。 FriendsDao.java, GroupInfoDao.java, GroupUserDao.java, HistoryMessagesDao.java, TypeInfoDao.java, TypeUserDao.java, UserInfoDao.java: 对应各个数据表的Mapper接口，继承自MyBatisPlus的BaseMapper，提供基本的CRUD操作。 com.mh.dto: 数据传输对象 (DTO) 包，用于封装请求参数和响应数据。 R.java: 通用的API响应结果封装类。 bo (Business Object): 业务对象，用于封装业务处理过程中的数据。 vo (View Object): 视图对象，用于封装返回给前端的数据。 com.mh.exception: 异常处理包。 GlobalExceptionAdvice.java: 全局异常处理器，统一处理应用中抛出的异常，返回友好的错误信息给前端。 MyTokenException.java: 自定义Token相关异常。 com.mh.pojo: 持久化对象 (POJO&#x2F;Entity) 包，对应数据库中的表结构。 Friends.java, GroupInfo.java, GroupUser.java, HistoryMessages.java, TypeInfo.java, TypeUser.java, UserInfo.java: 对应各个数据表的实体类。 com.mh.service: 服务层 (Service)，封装核心业务逻辑。 接口：FriendsService.java, GroupInfoService.java, GroupUserService.java, HistoryMessagesService.java, TypeInfoService.java, TypeUserService.java, UserInfoService.java。 实现类 (impl包): 对应各个Service接口的具体实现，调用DAO层操作数据，处理业务规则。 com.mh.task: 定时任务或异步任务包。 TaskOfInitReceiver.java: 初始化接收者相关任务。 TaskOfLoadDataToRedis.java: 将数据加载到Redis的任务。 TaskOfSaveMessage.java: 异步保存聊天消息的任务，通过消息队列触发。 com.mh.utils: 工具类包。 CommonUtil.java: 通用工具类。 ConvertUtil.java: 对象转换工具类。 EmailUtil.java: 邮件发送工具类。 JWTUtils.java: JWT (JSON Web Token) 生成和校验工具类，用于用户认证和会话管理。 resources: 资源文件目录。 application.properties: Spring Boot 核心配置文件，包含数据库连接、服务器端口、Redis、RabbitMQ等配置。 mapper/*.xml: MyBatis 的 SQL映射文件，定义了DAO接口对应的SQL语句。 技术选型： 核心框架： Spring Boot 持久层框架： MyBatisPlus 安全框架： Spring Security 实时通讯： Spring WebSocket 消息队列： RabbitMQ (用于异步处理、削峰填谷) 缓存： Redis (用于提升高频读取数据的性能) API文档： Swagger Token认证： JWT 2. 前端架构 (Vue.js)前端项目 vue 采用 Vue.js 作为核心框架，配合 Vue Router 进行路由管理，Vuex (或 Pinia) 进行状态管理，Axios 进行HTTP请求。前端负责用户界面的展示、用户交互的处理以及与后端API的通讯。 目录结构及主要文件作用： public/: 存放静态资源，会被直接复制到打包输出的根目录。 axiosConfig.js: Axios的全局配置，如基础URL、请求拦截器、响应拦截器等。 index.html: 应用的入口HTML文件。 src/: 项目源码目录。 App.vue: 根组件，所有页面组件的容器。 main.js: 应用的入口JavaScript文件，负责初始化Vue实例、路由、状态管理等。 router.js (或 src/router/index.js): Vue Router的配置文件，定义应用的路由规则和组件映射。 store/ (或 src/stores/): Vuex&#x2F;Pinia 的状态管理目录。 commonState.js: 可能包含一些全局共享的状态，如用户信息、登录状态等。 themeStore.js: 主题相关的状态管理。 assets/: 存放静态资源，如图片、字体等，会被Webpack处理。 components/: 可复用的UI组件目录。 Nav.vue: 导航栏组件。 Title.vue: 页面标题组件。 views/ (或直接在 src/ 下的模块化目录，如 login/, friends/ 等): 页面级组件目录，每个目录对应一个主要功能模块。 addF/AddF.vue, detail/Detail.vue, friends/Friends.vue, groupMessage/GroupMessage.vue, group/Group.vue, login/Login.vue, notice/Notice.vue, recover/Recover.vue, register/Register.vue, searchHistory/searchHistory.vue: 各个功能页面的Vue组件。 每个模块目录下通常包含 .vue (组件模板、脚本、样式)、.js (该模块的业务逻辑或API调用) 和可能的 index.html (如果是非SPA的独立页面入口)。 indexDB/: IndexedDB 相关操作的封装，用于客户端本地存储，例如缓存聊天记录、用户偏好设置等。 dbHistory.js, dbKV.js, dbUser.js: 对IndexedDB不同存储对象的封装。 utils/: 工具函数目录。 timeUtil.js: 时间处理相关的工具函数。 style.css: 全局CSS样式文件。 package.json: 项目依赖和脚本配置文件。 vite.config.js (或 vue.config.js): Vite&#x2F;Vue CLI 的构建配置文件。 技术选型： 核心框架： Vue.js (版本3) 构建工具： Vite (从 vite.config.js 推断) 路由管理： Vue Router 状态管理： 可能使用 Pinia (Vue 3推荐) 或 Vuex (从 store 目录结构推断) HTTP请求： Axios UI组件库： (未明确，可能为自定义组件或引入了第三方库如Element Plus, Ant Design Vue等) 本地存储： IndexedDB 3. 前后端交互 API接口： 后端通过 RESTful API 接口提供数据和服务，前端通过 Axios 发送HTTP请求调用这些接口。 实时通讯： 通过 WebSocket 实现客户端与服务器之间的双向实时通讯，用于聊天消息的即时发送和接收。 数据格式： 前后端交互数据主要采用 JSON 格式。 认证授权： 用户登录成功后，后端生成 JWT 返回给前端，前端在后续请求的 Header 中携带此 Token 进行身份验证。 4. 部署架构 (设想) 前端： 可以将Vue项目打包成静态文件，部署在Nginx等Web服务器上，或使用CDN加速。 后端： Spring Boot应用可以打包成JAR文件，通过 java -jar 命令运行，可以部署在物理服务器、虚拟机或Docker容器中。 数据库： MySQL数据库独立部署。 消息队列： RabbitMQ独立部署。 缓存： Redis独立部署。 负载均衡： 在高并发场景下，可以在后端应用服务器集群前部署负载均衡器 (如Nginx, HAProxy) 来分发请求。 这种分层和模块化的设计使得系统更易于维护、扩展和测试。 四、功能实现本章节将详细介绍在线聊天系统核心功能的实现思路，并展示相关的核心业务代码。后端代码主要位于 java-chat-room 项目中，前端代码位于 vue 项目中。以下代码片段主要摘自后端实现。 1. 登录与注册实现思路： 用户注册： 前端收集用户输入的邮箱、用户名、密码等信息。 前端进行基本的格式校验（如邮箱格式、密码强度等）。 后端接收注册请求，首先校验邮箱是否已被注册。 若邮箱可用，后端将用户密码进行加密处理（如使用 Spring Security 的 BCryptPasswordEncoder）。 生成唯一的用户ID (user_id)。 将用户信息（包括加密后的密码、user_id、邮箱、用户名等）存入 user_info 数据库表。 （可选）发送验证邮件到用户邮箱，用户点击链接激活账户。 返回注册成功或失败的信息给前端。 用户登录： 前端收集用户输入的邮箱和密码。 后端接收登录请求，根据邮箱查询 user_info 表获取用户信息。 若用户存在，则使用相同的加密算法（BCryptPasswordEncoder）校验用户输入的密码与数据库中存储的加密密码是否匹配。 若密码匹配成功，则认为登录成功。后端生成一个 JWT (JSON Web Token) 作为会话凭证，其中包含用户ID等信息，并设置一定的过期时间。 后端将 JWT 返回给前端。前端将其存储起来（例如在 localStorage 或 Vuex&#x2F;Pinia中），并在后续的请求中通过 HTTP Header (通常是 Authorization 字段，值为 Bearer &lt;token&gt;) 发送给后端进行身份验证。 返回登录成功信息（包含JWT和用户信息）或失败信息给前端。 密码找回： 用户输入注册邮箱，请求找回密码。 后端生成一个有时效性的验证码或重置链接，并通过邮件发送给用户。 用户通过邮件中的验证码或链接进入密码重置页面。 用户输入新密码，后端验证通过后，更新数据库中对应用户的密码（同样需要加密存储）。 核心代码示例 (后端)： 主要涉及 com.mh.controller.UserInfoController 和 com.mh.service.impl.UserInfoServiceImpl。 UserInfoController.java (部分代码 - 约30行) 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/user&quot;)public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; // 用户登录 @PostMapping(&quot;/login&quot;) public R login(@RequestBody LoginVo loginVo, HttpServletRequest request) &#123; return userInfoService.login(loginVo, request); &#125; // 用户注册 @PostMapping(&quot;/register&quot;) public R register(@RequestBody UserInfo userInfo) &#123; return userInfoService.register(userInfo); &#125; // 发送注册验证码 @GetMapping(&quot;/sendEmail&quot;) public R sendEmail(String email, Integer type) &#123; return userInfoService.sendEmail(email, type); &#125; // 修改密码 @PostMapping(&quot;/updatePassword&quot;) public R updatePassword(@RequestBody Map&lt;String, String&gt; map) &#123; return userInfoService.updatePassword(map.get(&quot;oldPassword&quot;), map.get(&quot;newPassword&quot;)); &#125;&#125; UserInfoServiceImpl.java (部分代码 - 约70行) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Servicepublic class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoDao, UserInfo&gt; implements UserInfoService &#123; @Autowired private UserInfoDao userInfoDao; @Autowired private BCryptPasswordEncoder bCryptPasswordEncoder; // 密码加密 @Autowired private StringRedisTemplate redisTemplate; @Autowired private EmailUtil emailUtil; @Override public R login(LoginVo loginVo, HttpServletRequest request) &#123; if (!StringUtils.hasText(loginVo.getEmail()) || !StringUtils.hasText(loginVo.getPassword())) &#123; return R.error(&quot;邮箱或密码不能为空&quot;); &#125; UserInfo user = userInfoDao.selectOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, loginVo.getEmail())); if (user == null) &#123; return R.error(&quot;用户不存在&quot;); &#125; // 校验密码 if (!bCryptPasswordEncoder.matches(loginVo.getPassword(), user.getPassword())) &#123; return R.error(&quot;密码错误&quot;); &#125; // 生成JWT String token = JWTUtils.createToken(user.getUserId(), user.getName()); LoginDataReturn data = new LoginDataReturn(token, user); return R.ok().data(&quot;loginData&quot;, data); &#125; @Override public R register(UserInfo userInfo) &#123; if (!StringUtils.hasText(userInfo.getEmail()) || !StringUtils.hasText(userInfo.getName()) || !StringUtils.hasText(userInfo.getPassword()))&#123; return R.error(&quot;注册信息不能为空&quot;); &#125; // 校验邮箱是否已注册 UserInfo existUser = userInfoDao.selectOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, userInfo.getEmail())); if (existUser != null) &#123; return R.error(&quot;该邮箱已被注册&quot;); &#125; // 密码加密 userInfo.setPassword(bCryptPasswordEncoder.encode(userInfo.getPassword())); userInfo.setUserId(UUID.randomUUID().toString()); // 生成唯一用户ID // 设置默认头像等 if(!StringUtils.hasText(userInfo.getPicture()))&#123; userInfo.setPicture(CommonStatic.DEFAULT_AVATAR); &#125; if (userInfoDao.insert(userInfo) &gt; 0) &#123; // 注册成功后，可以考虑自动创建默认好友分组等初始化操作 return R.ok(&quot;注册成功&quot;); &#125; return R.error(&quot;注册失败&quot;); &#125; // ... sendEmail 和 updatePassword 方法的实现 ...&#125; 2. 聊天管理（私聊，群聊）聊天管理是本系统的核心功能，主要通过 WebSocket 实现实时消息通讯，并通过 RabbitMQ 进行消息的异步持久化和可能的离线推送处理。 实现思路： WebSocket连接建立： 前端用户登录成功后，初始化 WebSocket 连接到后端的指定端点 (e.g., /ws/&#123;userId&#125;)。 后端 ChatWebSocketHandler 在 afterConnectionEstablished 方法中处理新的连接，记录用户ID与 WebSocket Session 的映射关系（例如存储在内存中的Map或Redis中），方便后续定向推送消息。 消息发送 (私聊&#x2F;群聊)： 前端用户在聊天界面输入消息，点击发送。 前端将消息内容（文本、表情标识等）、发送者ID、接收者ID（私聊为好友ID，群聊为群组ID）、消息类型（私聊&#x2F;群聊）等信息封装成JSON对象，通过 WebSocket 发送给后端。 后端 ChatWebSocketHandler 的 handleTextMessage 方法接收到消息。 后端解析消息内容，判断是私聊还是群聊。 消息路由与推送： 私聊： 根据接收者ID找到对应的 WebSocket Session，直接将消息转发给该 Session。 群聊： 根据群组ID查询 group_user 表获取所有群成员的用户ID列表。遍历成员列表，找到每个在线成员的 WebSocket Session，并将消息转发给他们。 消息异步处理： 为了不阻塞 WebSocket 线程并确保消息可靠存储，后端在接收到消息后，可以将消息发送到 RabbitMQ 消息队列中。 专门的消费者 (RabbitMessageListener) 监听该队列。 消费者从队列中取出消息，将其存入 history_messages 数据库表。 （可选）对于离线用户，可以在此步骤中判断并进行离线消息推送的准备（如集成第三方推送服务）。 消息接收： 前端 WebSocket 监听 onmessage 事件。 当接收到后端推送过来的消息时，前端解析消息内容，并将其展示在对应的聊天界面上。 聊天记录查询与下载： 前端请求指定好友或群组的聊天记录，可附带分页参数。 后端 HistoryMessagesController 接收请求，调用 HistoryMessagesService 查询 history_messages 表。 根据发送者、接收者（或群组ID）以及时间范围等条件进行查询，并按时间排序返回给前端。 下载聊天记录功能：后端查询出指定范围的聊天记录，将其格式化为特定文件格式（如 TXT, CSV, JSON），然后通过文件流的方式提供给前端下载。 语音聊天（基本思路）： 信令交互： 语音通话的建立、保持、挂断等过程需要信令服务器的支持。WebSocket 可以用来传递这些信令消息（如呼叫、应答、拒绝、挂断、ICE候选者信息、SDP描述等）。 媒体流传输： 实际的语音数据流通常通过 WebRTC (Web Real-Time Communication) 技术在客户端之间点对点 (P2P) 或通过媒体服务器 (如 TURN&#x2F;STUN 服务器) 进行传输。 后端主要负责信令的转发和用户状态的管理。history_messages 表中 msg_type 可以增加如 voice_call_offer, voice_call_answer 等类型来记录信令交互。 核心代码示例 (后端)： 主要涉及 com.mh.common.ChatWebSocketHandler, com.mh.config.WebSocketConfig, com.mh.service.impl.HistoryMessagesServiceImpl, com.mh.controller.HistoryMessagesController 以及 RabbitMQ 相关配置和监听器。 ChatWebSocketHandler.java (部分代码 - 约60行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Componentpublic class ChatWebSocketHandler implements WebSocketHandler &#123; private static final Logger log = LoggerFactory.getLogger(ChatWebSocketHandler.class); // 存储用户ID和WebSocketSession的映射 private static final Map&lt;String, WebSocketSession&gt; SESSIONS = new ConcurrentHashMap&lt;&gt;(); @Autowired private RabbitTemplate rabbitTemplate; // 用于发送消息到MQ @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; String userId = getUserIdFromSession(session); if (userId != null) &#123; SESSIONS.put(userId, session); log.info(&quot;用户 &#123;&#125; 连接成功，当前在线人数：&#123;&#125;&quot;, userId, SESSIONS.size()); // 可以发送上线通知等 &#125; &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; String userId = getUserIdFromSession(session); if (userId == null || !(message instanceof TextMessage)) &#123; return; &#125; String payload = ((TextMessage) message).getPayload(); log.info(&quot;收到用户 &#123;&#125; 的消息: &#123;&#125;&quot;, userId, payload); AcceptMessage acceptMessage = JSON.parseObject(payload, AcceptMessage.class); acceptMessage.setSender(userId); // 确保发送者是当前session的用户 // 将消息发送到RabbitMQ进行异步处理和持久化 rabbitTemplate.convertAndSend(&quot;chat.exchange&quot;, &quot;chat.message&quot;, JSON.toJSONString(acceptMessage)); // 实时推送给接收方 (如果是私聊且对方在线，或群聊成员在线) // 实际推送逻辑会更复杂，需要根据消息类型判断是私聊还是群聊，并找到对应的接收者 // 此处简化为示例，实际项目中会在MQ消费者或专门的推送服务中处理 if (&quot;private&quot;.equals(acceptMessage.getMsgType())) &#123; WebSocketSession receiverSession = SESSIONS.get(acceptMessage.getReceiver()); if (receiverSession != null &amp;&amp; receiverSession.isOpen()) &#123; receiverSession.sendMessage(new TextMessage(JSON.toJSONString(acceptMessage))); &#125; &#125; else if (&quot;group&quot;.equals(acceptMessage.getMsgType())) &#123; // 群聊消息推送给所有在线群成员 (需要查询群成员列表) // ... 此处省略群聊推送逻辑 ... &#125; &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; log.error(&quot;WebSocket连接出错: &#123;&#125;&quot;, getUserIdFromSession(session), exception); removeSession(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; log.info(&quot;用户 &#123;&#125; 断开连接: &#123;&#125;&quot;, getUserIdFromSession(session), closeStatus); removeSession(session); &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125; private String getUserIdFromSession(WebSocketSession session) &#123; // 从session的attributes中获取连接时传入的用户ID，通常在握手拦截器中设置 Map&lt;String, Object&gt; attributes = session.getAttributes(); return (String) attributes.get(CommonStatic.USER_ID_IN_WEBSOCKET_SESSION); &#125; private void removeSession(WebSocketSession session) &#123; String userId = getUserIdFromSession(session); if (userId != null) &#123; SESSIONS.remove(userId); log.info(&quot;用户 &#123;&#125; 的Session已移除，当前在线人数：&#123;&#125;&quot;, userId, SESSIONS.size()); &#125; &#125;&#125; RabbitMQConfig.java (部分代码 - 约20行) 1234567891011121314151617181920212223@Configurationpublic class RabbitMQConfig &#123; public static final String CHAT_EXCHANGE_NAME = &quot;chat.exchange&quot;; public static final String CHAT_QUEUE_NAME = &quot;chat.message.queue&quot;; public static final String CHAT_ROUTING_KEY = &quot;chat.message&quot;; @Bean public TopicExchange chatExchange() &#123; return new TopicExchange(CHAT_EXCHANGE_NAME, true, false); &#125; @Bean public Queue chatQueue() &#123; return new Queue(CHAT_QUEUE_NAME, true); &#125; @Bean public Binding chatBinding() &#123; return BindingBuilder.bind(chatQueue()).to(chatExchange()).with(CHAT_ROUTING_KEY); &#125;&#125; RabbitMessageListener.java (部分代码 - 约30行，用于消费MQ消息并存库) 123456789101112131415161718192021222324252627282930@Componentpublic class RabbitMessageListener &#123; private static final Logger log = LoggerFactory.getLogger(RabbitMessageListener.class); @Autowired private HistoryMessagesService historyMessagesService; @RabbitListener(queues = RabbitMQConfig.CHAT_QUEUE_NAME) public void receiveChatMessage(String message) &#123; log.info(&quot;从RabbitMQ接收到消息: &#123;&#125;&quot;, message); try &#123; AcceptMessage acceptMessage = JSON.parseObject(message, AcceptMessage.class); HistoryMessages historyMessage = new HistoryMessages(); BeanUtils.copyProperties(acceptMessage, historyMessage); historyMessage.setTimestamp(new Date()); // 使用服务器时间 // 根据消息类型，可能需要额外处理，如群聊时获取群名等 // historyMessage.setGroupName(acceptMessage.getGroupName()); historyMessagesService.save(historyMessage); log.info(&quot;消息已保存到数据库: &#123;&#125;&quot;, historyMessage.getId()); // 此处可以加入更复杂的推送逻辑，例如判断用户是否在线，如果不在线则走离线推送 // 也可以在此处将消息再通过WebSocket推送给目标用户/群组，以确保消息送达 // （ChatWebSocketHandler中的实时推送可以作为一种快速路径，MQ消费者作为可靠性保证和离线处理） &#125; catch (Exception e) &#123; log.error(&quot;处理RabbitMQ消息失败: &#123;&#125;&quot;, message, e); &#125; &#125;&#125; HistoryMessagesController.java (部分代码 - 约25行) 1234567891011121314151617181920212223242526272829@RestController@RequestMapping(&quot;/history&quot;)public class HistoryMessagesController &#123; @Autowired private HistoryMessagesService historyMessagesService; // 获取私聊历史记录 @GetMapping(&quot;/private/&#123;contactId&#125;&quot;) public R getPrivateHistory(@PathVariable String contactId, @RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;20&quot;) Integer size) &#123; // 需要获取当前登录用户ID，假设已通过Token解析获得 String currentUserId = &quot;...get current user id...&quot;; return historyMessagesService.getPrivateMessages(currentUserId, contactId, page, size); &#125; // 获取群聊历史记录 @GetMapping(&quot;/group/&#123;groupId&#125;&quot;) public R getGroupHistory(@PathVariable String groupId, @RequestParam(defaultValue = &quot;1&quot;) Integer page, @RequestParam(defaultValue = &quot;20&quot;) Integer size) &#123; return historyMessagesService.getGroupMessages(groupId, page, size); &#125; // 下载聊天记录的接口 (具体实现省略) // @GetMapping(&quot;/download/&#123;type&#125;/&#123;id&#125;&quot;) ...&#125; 3. 好友管理（要求可分组管理）好友管理功能允许用户添加、删除好友，对好友进行分组，以及处理好友请求等。 实现思路： 数据表设计： friends 表：存储好友关系 (user_id, friend_id, friend_group_id, status, create_time)。status 可以表示好友关系状态（如：normal, blocked）。 friend_groups 表：存储用户自定义的好友分组 (id, user_id, group_name)。 friend_requests 表：存储好友请求 (id, sender_id, receiver_id, message, status, create_time, update_time)。status 可以表示请求状态（如：pending, accepted, rejected）。 添加好友流程： 用户A搜索用户B或通过其他方式获取用户B的ID。 用户A向用户B发送好友请求，前端将用户A的ID (sender_id)、用户B的ID (receiver_id) 和验证信息 (message) 发送给后端。 后端 FriendsController 接收请求，在 friend_requests 表中创建一条记录，状态为 pending。 （可选）通过 WebSocket 或其他通知机制，实时通知用户B有新的好友请求。 用户B查看好友请求列表，可以选择接受或拒绝。 接受： 后端更新 friend_requests 表中对应记录的状态为 accepted。同时，在 friends 表中为用户A和用户B双向添加好友关系记录（例如，用户A的好友列表添加B，用户B的好友列表添加A），初始可以放在默认分组。 拒绝： 后端更新 friend_requests 表中对应记录的状态为 rejected。 删除好友： 用户A选择删除好友B。 后端 FriendsController 接收请求，在 friends 表中删除用户A与用户B之间的双向好友关系记录。 好友分组管理： 创建分组： 用户创建新的好友分组，前端将分组名称发送给后端，后端在 friend_groups 表中为该用户添加一条记录。 移动好友到分组： 用户选择一个好友和一个目标分组，前端将好友ID和目标分组ID发送给后端。后端更新 friends 表中对应好友记录的 friend_group_id 字段。 删除分组： 用户删除一个好友分组。后端需要考虑该分组下的好友如何处理，例如可以将其移动到默认分组。 重命名分组： 用户修改分组名称，后端更新 friend_groups 表中对应记录的 group_name。 获取好友列表（带分组）： 前端请求好友列表。 后端 FriendsController 调用 FriendsService。 FriendsService 首先查询 friend_groups 表获取该用户的所有分组。 然后遍历每个分组，查询 friends 表中属于该分组的好友，并关联查询 users 表获取好友的详细信息（如昵称、头像等）。 将结果组织成按分组的好友列表返回给前端。 重新发送验证信息： 如果好友请求长时间未处理或用户想再次提醒对方，可以提供“重新发送验证信息”功能。 这本质上是更新 friend_requests 表中对应请求的 update_time，并可能再次触发通知给接收方。 核心代码示例 (后端)： 主要涉及 com.mh.controller.FriendsController, com.mh.service.impl.FriendsServiceImpl。 FriendsController.java (部分代码 - 约50行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestController@RequestMapping(&quot;/friends&quot;)public class FriendsController &#123; @Autowired private FriendsService friendsService; // 发送好友请求 @PostMapping(&quot;/request&quot;) public R sendFriendRequest(@RequestBody FriendRequests request) &#123; // 需要设置 sender_id 为当前登录用户ID // String currentUserId = &quot;...get current user id...&quot;; // request.setSenderId(currentUserId); return friendsService.sendRequest(request); &#125; // 处理好友请求 (接受/拒绝) @PutMapping(&quot;/request/&#123;requestId&#125;&quot;) public R handleFriendRequest(@PathVariable Integer requestId, @RequestParam String action) &#123; // action: &quot;accept&quot; or &quot;reject&quot; // 需要获取当前登录用户ID，验证是否是请求的接收者 return friendsService.handleRequest(requestId, action, &quot;...current user id...&quot;); &#125; // 获取好友列表 (带分组) @GetMapping(&quot;/list&quot;) public R getFriendList() &#123; // String currentUserId = &quot;...get current user id...&quot;; return friendsService.getFriendsListWithGroups(&quot;...current user id...&quot;); &#125; // 删除好友 @DeleteMapping(&quot;/&#123;friendId&#125;&quot;) public R deleteFriend(@PathVariable String friendId) &#123; // String currentUserId = &quot;...get current user id...&quot;; return friendsService.deleteFriend(&quot;...current user id...&quot;, friendId); &#125; // 移动好友到分组 @PutMapping(&quot;/move&quot;) public R moveFriendToGroup(@RequestParam String friendId, @RequestParam Integer groupId) &#123; // String currentUserId = &quot;...get current user id...&quot;; return friendsService.moveFriendToGroup(&quot;...current user id...&quot;, friendId, groupId); &#125; // 创建好友分组 // @PostMapping(&quot;/group&quot;) ... // 删除好友分组 // @DeleteMapping(&quot;/group/&#123;groupId&#125;&quot;) ... // 重命名好友分组 // @PutMapping(&quot;/group/&#123;groupId&#125;&quot;) ...&#125; FriendsServiceImpl.java (部分代码 - 约70行) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@Servicepublic class FriendsServiceImpl extends ServiceImpl&lt;FriendsMapper, Friends&gt; implements FriendsService &#123; @Autowired private FriendRequestsMapper friendRequestsMapper; @Autowired private FriendsMapper friendsMapper; @Autowired private FriendGroupsMapper friendGroupsMapper; @Autowired private UserMapper userMapper; // 用于获取好友详细信息 @Override @Transactional public R sendRequest(FriendRequests request) &#123; request.setStatus(&quot;pending&quot;); request.setCreateTime(new Date()); request.setUpdateTime(new Date()); friendRequestsMapper.insert(request); // TODO: 通知接收方 return R.ok(&quot;好友请求已发送&quot;); &#125; @Override @Transactional public R handleRequest(Integer requestId, String action, String currentUserId) &#123; FriendRequests friendRequest = friendRequestsMapper.selectById(requestId); if (friendRequest == null || !friendRequest.getReceiverId().equals(currentUserId)) &#123; return R.error(&quot;请求不存在或无权操作&quot;); &#125; if (&quot;accept&quot;.equalsIgnoreCase(action)) &#123; friendRequest.setStatus(&quot;accepted&quot;); // 添加双向好友关系, 初始放入默认分组 (假设默认分组ID为0或特定逻辑获取) Friends friend1 = new Friends(null, friendRequest.getSenderId(), friendRequest.getReceiverId(), 0, &quot;normal&quot;, new Date()); Friends friend2 = new Friends(null, friendRequest.getReceiverId(), friendRequest.getSenderId(), 0, &quot;normal&quot;, new Date()); friendsMapper.insert(friend1); friendsMapper.insert(friend2); &#125; else if (&quot;reject&quot;.equalsIgnoreCase(action)) &#123; friendRequest.setStatus(&quot;rejected&quot;); &#125; else &#123; return R.error(&quot;无效操作&quot;); &#125; friendRequest.setUpdateTime(new Date()); friendRequestsMapper.updateById(friendRequest); return R.ok(&quot;操作成功&quot;); &#125; @Override public R getFriendsListWithGroups(String userId) &#123; // 1. 获取用户的所有分组 List&lt;FriendGroups&gt; groups = friendGroupsMapper.selectList(new LambdaQueryWrapper&lt;FriendGroups&gt;().eq(FriendGroups::getUserId, userId)); // 2. 遍历分组，获取每个分组下的好友 // (具体实现会更复杂，需要组装数据结构，这里仅为示意) // Map&lt;String, List&lt;User&gt;&gt; result = new HashMap&lt;&gt;(); // for (FriendGroups group : groups) &#123; // List&lt;Friends&gt; friendsInGroup = friendsMapper.selectList( // new LambdaQueryWrapper&lt;Friends&gt;() // .eq(Friends::getUserId, userId) // .eq(Friends::getFriendGroupId, group.getId()) // ); // List&lt;String&gt; friendIds = friendsInGroup.stream().map(Friends::getFriendId).collect(Collectors.toList()); // if (!friendIds.isEmpty()) &#123; // List&lt;User&gt; friendUsers = userMapper.selectBatchIds(friendIds); // result.put(group.getGroupName(), friendUsers); // &#125; // &#125; // return R.ok(result); return R.ok(&quot;好友列表获取逻辑待详细实现，涉及分组和好友信息查询&quot;); // 简化返回 &#125; @Override @Transactional public R deleteFriend(String userId, String friendId) &#123; // 删除双向好友关系 friendsMapper.delete(new LambdaQueryWrapper&lt;Friends&gt;().eq(Friends::getUserId, userId).eq(Friends::getFriendId, friendId)); friendsMapper.delete(new LambdaQueryWrapper&lt;Friends&gt;().eq(Friends::getUserId, friendId).eq(Friends::getFriendId, userId)); return R.ok(&quot;好友已删除&quot;); &#125; @Override public R moveFriendToGroup(String userId, String friendId, Integer groupId) &#123; Friends friendRelation = friendsMapper.selectOne( new LambdaQueryWrapper&lt;Friends&gt;().eq(Friends::getUserId, userId).eq(Friends::getFriendId, friendId) ); if (friendRelation != null) &#123; friendRelation.setFriendGroupId(groupId); friendsMapper.updateById(friendRelation); return R.ok(&quot;好友已移动到新分组&quot;); &#125; return R.error(&quot;好友关系不存在&quot;); &#125;&#125; 五、界面成果展示在此处手动粘贴项目的各个主要功能的界面截图。例如： 登录界面 注册界面 找回密码界面 好友列表界面（展示分组） 私聊聊天界面 群聊聊天界面 好友请求通知界面 个人信息&#x2F;设置界面 （如果实现了语音聊天）语音发送界面 六、总结本项目 “在线聊天系统” 成功实现了用户登录注册、聊天管理（包括私聊、群聊、聊天记录查询与下载）以及好友管理（包括分组管理、添加删除好友、好友请求处理）等核心功能。项目采用了 Spring Boot + Vue.js 的前后端分离架构，后端使用 MyBatis Plus 操作 MySQL 数据库，通过 WebSocket 实现实时通讯，并利用 RabbitMQ 进行消息的异步处理和持久化。语音聊天功能作为可选实现，也给出了基本的技术思路。 在开发过程中，我们注重代码的模块化和可维护性，对核心业务逻辑进行了详细设计和实现。通过本项目的实践，我们加深了对实时通讯技术、消息队列以及常用后端框架的理解和应用。 当然，系统仍有可完善和扩展的空间，例如： 更完善的离线消息推送机制。 文件传输功能。 更丰富的表情和多媒体消息支持。 用户在线状态的精确显示与更新。 更细致的权限管理和安全性增强。 总体而言，本项目达到了预期的设计目标，为用户提供了一个稳定、易用的在线交流平台。 补充(非必要）： 七、技术选型补充说明在架构设计中，我们选择了Spring WebSocket作为实时通讯方案，而非Netty等底层框架。主要考量如下： 技术特性 Spring WebSocket Netty 开发效率 高，与Spring生态无缝集成，提供高级抽象和便利的API。 低，需要手动处理底层协议和连接管理，开发周期长。 生态整合 完美融入Spring Boot项目，易于与其他Spring组件（如Spring Security, Spring Data）结合。 独立框架，与其他框架整合需要额外工作。 功能丰富性 提供消息处理、会话管理、拦截器等开箱即用的功能。 仅提供底层网络通信能力，上层功能需自行实现。 社区支持 拥有庞大的Spring社区支持和丰富的文档。 社区活跃，但更偏向底层网络编程专家。 适用场景 适用于快速开发、业务逻辑复杂的Web应用实时通讯。 适用于对性能有极致要求、需要高度定制化网络协议的场景。 综合考虑开发效率、与现有Spring生态的整合度以及项目需求，Spring WebSocket是更优的选择，它能让我们更专注于业务逻辑的实现，而非底层网络细节。 八、安全加固措施为了保障系统的安全性和用户数据的隐私，本项目在设计和实现中考虑了以下安全加固措施： 1. 用户认证与授权 密码加密存储： 用户密码采用Spring Security的BCryptPasswordEncoder进行加密存储，确保即使数据库泄露，密码也无法被直接获取。 JWT认证： 使用JWT（JSON Web Token）进行用户身份认证。JWT包含签名，有效防止篡改。同时，通过设置合理的过期时间，并结合Redis存储黑名单或刷新令牌机制，实现令牌的有效管理和吊销。 接口权限控制： 利用Spring Security的拦截器和注解，对敏感API接口进行权限控制，确保只有经过认证和授权的用户才能访问。 2. 消息传输安全 WebSocket安全连接： 部署时建议使用WSS（WebSocket Secure）协议，通过TLS&#x2F;SSL加密传输通道，防止消息在传输过程中被窃听或篡改。 消息内容加密（可选）： 对于极度敏感的消息内容，可以在应用层进行端到端加密（例如使用AES-GCM算法），确保只有发送方和接收方能解密消息。 3. 常见安全漏洞防范 SQL注入： 采用MyBatisPlus作为持久层框架，其提供的Mapper接口和Wrapper查询方式能有效防止SQL注入。 XSS攻击： 对用户输入的内容进行严格的过滤和转义，尤其是在前端展示时，防止恶意脚本的注入。 CSRF攻击： 对于非GET请求，可以考虑引入CSRF Token机制进行防护。 文件上传安全： 限制文件上传类型和大小，对上传文件进行病毒扫描，并将文件存储在非Web可访问的目录，通过代理或专门的文件服务提供访问。 九、部署架构可视化以下是本在线聊天系统的部署架构示意图，展示了主要组件及其之间的交互关系： 12345678910graph TD A[用户浏览器/客户端] --&gt;|HTTPS/WSS| B(负载均衡器 Nginx/HAProxy) B --&gt;|HTTP/WS| C[后端应用服务 Spring Boot集群] C --&gt;|TCP| D(消息队列 RabbitMQ集群) C --&gt;|TCP| E(缓存服务 Redis哨兵模式) C --&gt;|TCP| F(数据库 MySQL主从复制) C --&gt;|文件存储| G(对象存储 MinIO/OSS) D --&gt;|消息消费| C E --&gt;|数据同步| C F --&gt;|数据读写| C 说明： 用户浏览器&#x2F;客户端： 用户通过Web浏览器或移动应用访问系统。 负载均衡器 (Nginx&#x2F;HAProxy)： 负责将用户请求分发到后端应用服务集群，实现负载均衡和高可用。 后端应用服务 (Spring Boot集群)： 承载核心业务逻辑，可横向扩展以应对高并发。 消息队列 (RabbitMQ集群)： 用于异步处理消息、削峰填谷，提高系统响应速度和可靠性。 缓存服务 (Redis哨兵模式)： 提供高性能缓存，存储用户在线状态、会话信息等，减轻数据库压力，哨兵模式保证高可用。 数据库 (MySQL主从复制)： 存储用户数据、聊天记录等持久化数据，主从复制保证数据冗余和读写分离。 对象存储 (MinIO&#x2F;OSS)： 用于存储用户上传的图片、文件、语音等非结构化数据。 十、未来扩展与规划为了使本在线聊天系统更具健壮性、可扩展性和功能丰富性，未来可以考虑以下方向的扩展和优化： 1. 功能增强 文件传输功能： 支持用户之间发送图片、文档、视频等文件，可集成MinIO等对象存储服务。 音视频通话： 基于WebRTC实现更完善的音视频通话功能，包括多人会议、屏幕共享等。 离线消息与消息漫游： 优化离线消息推送机制，实现消息在多设备间的无缝漫游。 表情与富文本支持： 增加更多自定义表情、GIF动图以及富文本消息的发送与展示。 消息撤回与编辑： 提供已发送消息的撤回和编辑功能。 机器人与插件： 引入聊天机器人或第三方插件，扩展聊天场景和互动方式。 2. 性能与可伸缩性优化 消息历史记录冷热分离： 对于海量的历史消息，可以考虑将近期消息存储在MySQL，而将更早期的消息归档到HBase或Elasticsearch等分布式存储中，以提高查询效率。 分布式追踪： 引入SkyWalking、Zipkin等分布式追踪系统，对请求链路进行监控和分析，便于故障排查和性能瓶颈定位。 服务网格： 在微服务架构下，引入Istio等服务网格，提供流量管理、熔断、限流、服务发现等能力。 3. 安全与运维 更细致的权限管理： 实现基于角色的访问控制（RBAC），对不同用户角色赋予更精细的操作权限。 日志管理与监控： 搭建ELK（Elasticsearch, Logstash, Kibana）或Prometheus+Grafana等日志监控系统，实时监控系统运行状态和异常。 自动化部署： 引入Jenkins、GitLab CI&#x2F;CD等工具，实现代码提交、测试、部署的自动化流程。 附录附录A：数据库表结构设计（此处可再次详细列出所有数据库表的字段、类型、约束、索引等信息，或引用“二、数据库设计”章节） 附录B：API接口文档（此处可提供Swagger UI的访问地址或导出API文档，详细说明每个接口的请求方式、URL、参数、响应示例等） 附录C：项目源码地址 后端项目： [Gitee地址] 前端项目： [Gitee地址] 附录D：开发环境与部署环境 开发环境： JDK版本：1.8+ Maven版本：3.6+ Node.js版本：14+ IDE：IntelliJ IDEA, VS Code 部署环境： 操作系统：Linux (CentOS&#x2F;Ubuntu) Web服务器：Nginx 应用容器：Docker 数据库：MySQL 8.0+ 消息队列：RabbitMQ 3.x+ 缓存：Redis 6.x+","categories":[{"name":"Web程序设计","slug":"Web程序设计","permalink":"http://mu1226.github.io/categories/Web%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"大作业","slug":"大作业","permalink":"http://mu1226.github.io/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}]},{"title":"Web实验七——个人博客的搭建及部署","slug":"Web实验七——个人博客的搭建及部署","date":"2025-05-14T07:48:49.000Z","updated":"2025-05-29T02:08:31.910Z","comments":true,"path":"2025/05/14/Web实验七——个人博客的搭建及部署/","permalink":"http://mu1226.github.io/2025/05/14/Web%E5%AE%9E%E9%AA%8C%E4%B8%83%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2/","excerpt":"","text":"前言近期都比较忙，但是不知道在忙什么。从开学到现在，除了放假的时候会”啸啸休息亿下”，其他时间几乎都是在图书馆与电脑打交道。迷迷糊糊的就做到了第七个实验，实际上对于这个实验，我去年就应该是做过了。当时跟风想做一个个人博客，就网上搞了一套教程跟着学，但是其实也没学多久。因为那个时候对于”前端“这个东西还不是很熟悉（现在也只能说是”略知一二“），就导致别人好看的博客页面的代码我完全看不下去，从而使得我的Web学习”半途而废“，我的博客也就开始了他长达一年的”沉寂“…再次重启我的博客项目已经是一年后的今天了，实验前回顾了以下我以前的博客项目，我脑海里瞬间有个念想——“这玩意实在是太丑了，我完全看不下去，我一定要改掉它！“。于是，我便开始”大刀阔斧“地进行改造。实际上，我主要还是受到了Web大作业的影响，在我们的团队中，我主要负责前端的开发部分，想着拿自己的博客练练手，检验一下”石粒“。 正文那我们废话不多说，直接开始实验的内容… 实验七的要求如下所示： 在发布博客的页面中显示至少两张图片 其中一张的引用方式为绝对路径(http://xxxx.com/xxxx.png) 另外一张为相对路径(..&#x2F;image&#x2F;xxxx.png) 实际上，我们在当前博客的构建中已经完成上面要求的一半，我们接下来将在本篇博文中展现两张图片，如下图所示： 采用绝对路径的图片显示以下图片的绝对路径如下，实际上也就是我的GitHub平台的头像…https://avatars.githubusercontent.com/u/174580656 采用相对路径的图片显示以下图片存放于本地，实际上也就是我Gitee平台的头像… 思考到这里实验的内容部分已然完成，接下来是对于思考题的分析。至于为什么要这么一段话放在这里，主要还是因为我有强迫症，根据标题之间需要字的过渡才好看… 思考题一在页面中是否可以引入本地绝对路径图片，如：d:&#x2F;images&#x2F;1.png？原因是什么？ 不可以，原因主要有以下几点： 浏览器安全限制：浏览器出于安全考虑，禁止直接访问本地文件系统（如 file:&#x2F;&#x2F;&#x2F;D:&#x2F;images&#x2F;1.png），否则恶意网页可以随意读取用户硬盘数据； HTTP协议要求：网页必须通过 HTTP&#x2F;HTTPS 协议加载资源，而 D:&#x2F;images&#x2F;1.png 是本地文件路径，无法被服务器托管； GitHub Pages的限制：即使你在本地测试时能显示 file:&#x2F;&#x2F;&#x2F; 路径的图片，上传到GitHub Pages后，所有路径必须基于相对路径或网络绝对路径； 思考题二由于github.io为静态页面托管，如何为自己的博客添加评论功能？ 可以通过以下方式实现评论： 使用 GitHub Issues：将每篇博文的评论关联到 GitHub Issues，利用 GitHub API 提交和显示评论； 第三方评论系统（无需登录）：Disqus、Commento、Talkyard等等，支持匿名评论，无需用户拥有 GitHub 账号； 自建评论系统：实际上，也可以手搓一个评论系统（顺手的事），具体技术栈可能涉及到：后端：Vercel + Serverless Function（如 Next.js API）、数据库：Firebase &#x2F; Supabase &#x2F; MongoDB Atlas（免费层）、前端：静态博客通过 fetch 调用 API；","categories":[{"name":"Web程序设计","slug":"Web程序设计","permalink":"http://mu1226.github.io/categories/Web%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://mu1226.github.io/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-05-14T07:16:55.280Z","updated":"2025-05-14T07:16:55.280Z","comments":true,"path":"2025/05/14/hello-world/","permalink":"http://mu1226.github.io/2025/05/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2024-08-03T03:46:59.000Z","updated":"2025-05-29T02:08:56.171Z","comments":true,"path":"2024/08/03/我的第一篇博客/","permalink":"http://mu1226.github.io/2024/08/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"由于是第一篇博客，我也没想好具体要写什么东西:) 参考视频网站www.bilibili.com","categories":[{"name":"Init Categories","slug":"Init-Categories","permalink":"http://mu1226.github.io/categories/Init-Categories/"}],"tags":[{"name":"Init Tags","slug":"Init-Tags","permalink":"http://mu1226.github.io/tags/Init-Tags/"}]}],"categories":[{"name":"Web程序设计","slug":"Web程序设计","permalink":"http://mu1226.github.io/categories/Web%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Init Categories","slug":"Init-Categories","permalink":"http://mu1226.github.io/categories/Init-Categories/"}],"tags":[{"name":"大作业","slug":"大作业","permalink":"http://mu1226.github.io/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"实验","slug":"实验","permalink":"http://mu1226.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"Init Tags","slug":"Init-Tags","permalink":"http://mu1226.github.io/tags/Init-Tags/"}]}